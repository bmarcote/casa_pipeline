"""Contains all functions concerning calibration of a VLBI project in MS format within (or out) CASA.
"""
import shutil
from pathlib import Path
from dataclasses import dataclass
import casatasks
from casatasks.private import tec_maps
import casatools
from astropy import units as u
from . import project




"""Diferent functions that can be used directly from this module in order to calibrate the data.
Later on a class Calibration is defined, which will use these functions but by using the Project/Ms objects.
"""
@dataclass
class CallibEntry:
    """Defines an entry in a calibration tables library.
    It contains a name (label to refer to which step did this calibration entry) and the full entry
    to be written in a callib file.
    """
    name: str
    calfile: str
    parameters: str


class Callib(object):
    @property
    def filename(self) -> Path:
        return self._filename

    @filename.setter
    def filename(self, new_filename: Path):
        assert isinstance(new_filename, Path)
        self._filename = new_filename

    @property
    def entries(self) -> list:
        return self._entries

    @property
    def entry_names(self) -> list:
        return [entry.name for entry in self._entries]

    @property
    def entry_calfiles(self) -> list:
        return [entry.calfile for entry in self._entries]

    @property
    def entry_params(self) -> list:
        return [entry.parameters for entry in self._entries]

    def __init__(self, filename: Path):
        self.filename = filename
        self._entries = []

    def associated_caltable(self, name: str):
        return self._entries[self.entry_names.index(name)].calfile

    def associated_parameters(self, name: str):
        return self._entries[self.entry_names.index(name)].parameters

    def new_entry(self, name: str, calfile: str, parameters: str):
        if name in self.entry_names:
            self._entries[self.entry_names.index(name)] = CallibEntry(name, calfile, parameters)
        else:
            self.entries.append(CallibEntry(name, calfile, parameters))

        self.update_file()

    def remove_entry(self, name: str):
        """Removes the entry in the callib that was generated by the given name.
        If 'all', it will empty the callib.
        """
        if name == 'all':
            self._entries = []
        else:
            self._entries.pop(self.entry_names.index(name))

        self.update_file()

    def remove_entry_and_table(self, name: str):
        if name == 'all':
            for calfile in self.entry_calfiles:
                if os.path.isdir(calfile):
                    shutil.rmtree(calfile)

            self._entries = []
        else:
            calfile = self.associated_caltable(name)
            if os.path.isdir(calfile):
                shutil.rmtree(calfile)

            self._entries.pop(self.entry_names.index(name))

        self.update_file()

    def update_file(self):
        with open(self.filename, 'w') as callib_file:
            for a_step in self.entries:
                callib_file.write(f"# {a_step.name}\n")
                callib_file.write(f"{a_step.parameters}\n")


def remove_if_exists(a_table: Path):
    """Removes the table if exists.
    """
    # a_table should always be a Path, but just in case this converts it if it is only a string
    if not isinstance(a_table, Path):
        Path(a_table)
        print(f"WARNING: {a_table} is a str, not a Path (it should, but I am converting it now).")

    if a_table.exists():
        print(f"{a_table} exists and will be removed and overwriten.")
        shutil.rmtree(a_table)


def get_spw_global_fringe(caltable: Path) -> int:
    """Returns the subband (spw) where the solutions from a global fringe run have been stored.
    Note that when combining spw in fringe, it will write the solutions in the first subband with
    data (so in general spw = 0; but not always).
    This function reads the generated calibration table and returns the number of the spw where
    the solutions where actually stored.
    """
    tb = casatools.table()
    tb.open(caltable.name)
    tb.open(tb.getkeyword('SPECTRAL_WINDOW').replace('Table: ', ''))
    the_spw = int(tb.getcol('MEAS_FREQ_REF')[0])
    tb.close()
    tb.close()
    return the_spw



class Calibration(object):
    """Class containing the calibration tools required for VLBI data reduction.
    """

    @property
    def caldir(self) -> Path:
        """Returns the Path to the directory where all calibration tables are stored.
        """
        return self._caldir

    @property
    def callib(self) -> Callib:
        """Returns the Callib file associated to the current calibration.
        """
        return self._callib

    @property
    def sbd_timerange(self) -> str:
        """Returns the time range to used to compute the instrumental delay correction.
        """
        return self._sbd_timerange

    @sbd_timerange.setter
    def sbd_timerange(self, new_timerange: str):
        self._sbd_timerange = new_timerange

    def __init__(self, ms_obj, caldir: Path = Path('./calibration_tables/')):
        self._ms = ms_obj
        self._caldir = caldir
        self._callib = Callib(caldir / 'callibrary.txt')
        self._sbd_timerange = None

    def a_priori_calibration(self):
        """Generates the calibration tables for gain and system temperature.
        Existing versions of the calibration will be removed first.
        """
        caltsys = self.caldir / f"{str(self._ms.msfile).lower()}.tsys"
        calgc = self.caldir / f"{str(self._ms.msfile).lower()}.gc"
        if not caltsys.exists():
            print(f"Generating Tsys calibration table {caltsys}.")
            casatasks.gencal(vis=str(self._ms.msfile), caltable=str(caltsys), caltype='tsys', uniform=False)
            self.callib.new_entry(name='tsyscal', calfile=str(caltsys),
                                  parameters=f"caltable='{str(caltsys)}' tinterp='nearest' finterp='nearest'")
            print(f"Tsys calibration table {caltsys} properly generated.")
        else:
            print(f"{caltsys} (Tsys corrections) already exists. It will not be generated again.")

        if not calgc.exists():
            print(f"Generating GC calibration table {calgc}.")
            casatasks.gencal(vis=str(project.msfile), caltable=str(calgc), caltype='gc')
            self.callib.new_entry(name='gccal', calfile=str(calgc),
                                  parameters=f"caltable='{calgc}' tinterp='nearest' finterp='nearest'")
            print(f"GC calibration table {calgc} properly generated.")
        else:
            print(f"{calgc} (Gain Curve corrections) already exists. It will not be generated again.")


    def accor(self):
        """NOTE: This should never be run on EVN data!!!!!!!!!!!!!!!!!!!!!!!!!

        It is written here for compatibility and internal tests.
        """
        accor_caltable = self.caldir / f"{str(self._ms.msfile).lower()}.accor"
        accor_caltable_smooth = self.caldir / f"{str(self._ms.msfile).lower()}.accor_smooth"
        if not accor_caltable_smooth.exists():
            print(f"Generating ACCOR calibration table {accor_caltable_smooth}.")
            casatasks.accor(vis=str(self._ms.msfile), caltable=str(accor_caltable), solint='30s',
                            docallib=True, callib=str(project.caldir / "cal_library.txt"))
            casatasks.smoothcal(vis=str(project.msfile), tablein=accor_caltable, caltable=accor_caltable_smooth,
                                smoothtype='median', smoothtime=1800.0)
            self.callib.new_entry(name='accor', calfile=str(accor_caltable_smooth),
                                  parameters=f"caltable='{accor_caltable_smooth}' tinterp='nearest'  " \
                                             "finterp='linear'")
            print(f"ACCOR calibration table {accor_caltable_smooth} properly generated.")
        else:
            print(f"{accor_caltable_smooth} (ACCOR corrections) already exists. It will not be generated again.")


    def ionospheric_corrections(self):
        """Runs the ionospheric calibration if required (i.e. if the observation was conducted at less than 6 GHz).
        This can also be turned off in the input parameter files.
        """
        #TODO: change this inputs accordingly to the final structure of the input file.
        if (self._ms.freqsetup.frequency < 6*u.GHz) and (self._ms.inputs['do_ionospheric']):
            caltec = self.caldir / f"{str(self._ms.msfile).lower()}.tec"
            imtec  = self.caldir / f"{str(self._ms.msfile).lower()}"
            if not caltec.exists():
                print("Calibrating the ionospheric TEC influence.")
                tec_maps.create(vis=str(self._ms.msfile), doplot=False, imname=str(imtec))
                casatasks.gencal(vis=str(self._ms.msfile), caltable=str(caltec),
                                 infile=f"{imtec}.IGS_TEC.im", caltype='tecim')
                self.callib.new_entry(name='teccor', calfile=str(caltec), parameters=f"caltable='{caltec}'")
                print(f"Ionospheric TEC correction {caltec} properly generated.")
            else:
                print(f"{caltec} (ionospheric corrections) already exists. It will not be generated again.")
        else:
            print('No ionospheric calibration required for this experiment.')


    def compute_sbd_timerange(self, interval='2min') -> str:
        """Localizes a good time to compute the ionospheric corrections and returns it.
        It goes through the fringe-finder sources, and then through the scans from these ones selecting the
        time interval right in the middle of the scan or at the end of the same.
        Then it will do a basic statistics you select the best interval, by the following checks:
          1) the one containing all antennas
          2) the one with a smaller rms of the rms on each baseline.
          3) the one with higher amplitudes in all baselines (checking the min amplitude).
        """
        #TODO: implement or pass it by the user
        raise NotImplementedError
        if self._sbd_timerange is not None:
            return self._sbd_timerange


    def main_calibration(self):
        """Runs the main calibration of the data:
        - instrumental delay corrections: in the specified time range.
        - global fringe fit: on all calibrators (and target if no phase-referencing is used).
        - bandpass calibration: using the bandpass calibrators.
        """
        #TODO: add the possibility of using a source model for fringe.
        cals = {'sbd': (self.caldir/f"{str(self._ms.msfile).lower()}.sbd"),
                'mbd': (self.caldir/f"{str(self._ms.msfile).lower()}.mbd"),
                'bp': (self.caldir/f"{str(self._ms.msfile).lower()}.bp")}

        if cals['sbd'].exists():
            print(f"No instrumental delay calibration performed as the table {cals['sbd']} already exists.")
        else:
            casatasks.fringefit(vis=str(self._ms.msfile), caltable=str(cals['sbd']),
                                timerange=project.params['sbd_timerange'], solint='inf', zerorates=True,
                                refant=','.join(self._ms.refant), minsnr=50, docallib=True,
                                callib=str(self.callib), parang=True)
            self.callib.new_entry(name='sbd', calfile=str(cals['sbd']),
                                  parameters=f"caltable='{cals['sbd']}' tinterp='nearest'")

        if cals['mbd'].exists():
            print(f"No multi-band delay calibration performed as the table {cals['mbd']} already exists.")
        else:
            casatasks.fringefit(vis=str(self._ms.msfile), caltable=str(cals['mbd']),
                                field=','.join(self._ms.calibrators), solint='inf', zerorates=False,
                                refant=','.join(self.refant), combine='spw', minsnr=5, docallib=True,
                                callib=str(self.callib), parang=True)
            spw_with_solutions = get_spw_global_fringe(caltable=str(cals['mbd']))
            self.callib.new_entry(name='mbd', calfile=str(cals['mbd']),
                                  parameters=f"caltable='{cals['mbd']}' tinterp='linear' " \
                                             f"spwmap={project.nsubbands*[spw_with_solutions]}")

        if cals['bp'].exists():
            print(f"No bandpass calibration performed as the table {cals['bp']} already exists.")
        else:
            casatasks.bandpass(vis=str(self._ms.msfile), field=','.join(self._ms.sources.fringe_finders.names),
                               combine='scan', caltable=str(cals['bp']), docallib=True,
                               callib=str(self.callib), solnorm=True, solint='inf',
                               refant=','.join(self._ms.refant), bandtype='B', parang=True, fillgaps=16)
            self.callib.new_entry(name='bandpass', calfile=str(cals['bp']),
                                  parameters=f"caltable='{cals['bp']}' tinterp='linear' finterp='linear'")

    # TODO: between std calibration and recalibration a flagging with the TRFLG or whatever should run

    def recalibration(self):
        """Runs the main calibration of the data:
        - instrumental delay corrections: in the specified time range.
        - global fringe fit: on all calibrators (and target if no phase-referencing is used).
        - bandpass calibration: using the bandpass calibrators.
        """
        #TODO: add the possibility of using a source model for fringe.
        cals = {'sbd2': self.caldir/f"{str(self._ms.msfile).lower()}.sbd2",
                'mbd2': self.caldir/f"{str(self._ms.msfile).lower()}.mbd2"}

        if cals['sbd2'].exists():
            print(f"No second instrumental delay calibration performed as the table {cals['sbd2']} already exists.")
        else:
            casatasks.fringefit(vis=str(self._ms.msfile), caltable=str(cals['sbd2']),
                                timerange=project.params['sbd_timerange'], solint='inf', zerorates=True,
                                refant=','.join(self._ms.refant), minsnr=50, docallib=True,
                                callib=str(self.callib), parang=True)
            self.callib.new_entry(name='sbd2', calfile=str(cals['sbd2']),
                                  parameters=f"caltable='{cals['sbd2']}' tinterp='nearest'")

        if cals['mbd2'].exists():
            print(f"No second multi-band delay calibration performed as the table {cals['mbd2']} already exists.")
        else:
            casatasks.fringefit(vis=str(self._ms.msfile), caltable=str(cals['mbd2']),
                                field=','.join(self._ms.calibrators), solint='inf', zerorates=False,
                                refant=','.join(self.refant), combine='spw', minsnr=5, docallib=True,
                                callib=str(self.callib), parang=True)
            spw_with_solutions = get_spw_global_fringe(caltable=str(cals['mbd2']))
            self.callib.new_entry(name='mbd2', calfile=str(cals['mbd2']),
                                  parameters=f"caltable='{cals['mbd2']}' tinterp='linear' " \
                                             f"spwmap={project.nsubbands*[spw_with_solutions]}")


    def apply_calibration(self):
        """Applies the current calibration by using the tables written in the callib.
        """
        casatasks.applycal(vis=str(self._ms.msfile), docallib=True,
                           callib=self.callib, parang=True)


    def split(self):
        """Splits all the data from all calibrated sources.
        """
        for a_source in self._ms.sources:
            casatasks.split(vis=str(self._ms.msfile),
                            outputvis=str(self._ms.msfile).replace(".ms", f".{a_source}.ms"),
                            field=a_source, datacolumn='corrected', antenna='!&&&',
                            width=self._ms.freqsetup.nchannels)
            # TODO: apply flags? there is a parameter like that
            # TODO: craete new Ms objects for each ms so it has
            ########################## NOO:  this functions should be in Ms, not in calibration.


    def export_uvfits(self):
        """Export the available SPLIT files into a UVFITS file.
        """
        for a_source in self._ms.sources:
            casatasks.exportuvfits(vis=str(self._ms.msfile).replace(".ms", f".{a_source}.ms"),
                                   fitsfile=str(self._ms.msfile).replace(".ms", f".{a_source}.uvfits"),
                                   multisource=False, combinespw=True, padwithflags=True)



    # def self_calibration(project: project.Project, source_model: str, calmode: str, solint: int):
    #     raise NotImplementedError
    #     # Maybe just a function that calls in loop all expected iteractions: p, p, p, a&p, p, a&p, p
    #     # In the amplitude selfcal (not the gscale with combine scan), use solnorm=True so it only corrects for
    #     # time-dependent gain residuals, not the flux scale.
    #
    #     # First, let's refine the delays
    #     gaincal(vis='tl016b_cal1.ms', field='J1154+6022', caltable='tl016b_cal1.dcal', solint='inf', refant=project.refants, minblperant=3, gaintype='K', calmode=calmode, parang=False)




    # def self_calibration_from_difmap_image(project: project.Project):
    #     """
    #     Project needs to contain the difmap associated images!!!!!!!!!!!
    #
    #     Note that Difmap FITS images exhibit a scale that is missunderstood by CASA by a factor 1000.
    #     This task automatically corrects for it when importing the model in the MS file.
    #     """
    #     raise NotImplementedError
    #     # Assumes the model is a FITS file image generated by Difmap
    #     for a_cal in project.phase_calibrators:
    #         calsc = project.caldir / f"{project.project_name.lower()}.{a_cal}.sc_final"
    #         # TODO: check if ft is in casatools or casatasks
    #         # NOT IN MSFILE BUT IN SPLIT FILES
    #         casatools.ft(vis=str(project.msfile), field=a_cal, model=str(src_model), usescratch=True)
    #         # Here open the MS, getcol MODEL_XX  divide all complex numbers by 1000 and load it again.
    #         casatasks.gaincal(vis=str(project.msfile), caltable=str(calsc), field=a_cal, solint='3min',
    #                           refant=','.join(project.refants), gaintype='G', calmode='ap', interp=['nearest'],
    #                           parang=True)
    #         casatasks.applycal()
    #
